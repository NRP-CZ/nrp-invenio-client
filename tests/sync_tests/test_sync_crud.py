#
# Copyright (C) 2024 CESNET z.s.p.o.
#
# invenio-nrp is free software; you can redistribute it and/or
# modify it under the terms of the MIT License; see LICENSE file for more
# details.
#

#
# This file was generated from the asynchronous client at test_async_crud.py by generate_synchronous_client.sh
# Do not edit this file directly, instead edit the original file and regenerate this file.
#


#
# Copyright (C) 2024 CESNET z.s.p.o.
#
# invenio-nrp is free software; you can redistribute it and/or
# modify it under the terms of the MIT License; see LICENSE file for more
# details.
#
import pytest
from rich import print

from invenio_nrp.client import SyncClient
from invenio_nrp.client.errors import RepositoryCommunicationError
from invenio_nrp.client.sync_client.files import File
from invenio_nrp.client.sync_client.records import Record
from invenio_nrp.client.sync_client.request_types import RequestType
from invenio_nrp.client.sync_client.requests import Request
from invenio_nrp.types import Model


def test_create_record(local_client: SyncClient):
    records_client = local_client.user_records()
    rec = records_client.create_record(
        {"metadata": {"title": "test"}}, community="acom"
    )
    assert isinstance(rec, Record)
    print(rec)
    assert rec.id is not None
    assert rec.metadata["title"] == "test"
    assert rec.parent["communities"]["default"] is not None


@pytest.mark.skip()
def test_create_record_with_default_community(local_client: SyncClient):
    records_client = local_client.user_records()
    rec = records_client.create_record({"metadata": {"title": "test"}})
    assert isinstance(rec, Record)


def test_get_record(local_client: SyncClient):
    records_client = local_client.user_records()
    rec = records_client.create_record(
        {"metadata": {"title": "test"}}, community="acom"
    )

    # read the record given the pid
    rec2 = records_client.read_record(record_id=rec.id)
    assert rec.metadata == rec2.metadata
    assert rec.id == rec2.id

    # read the record given the url
    rec3 = records_client.read_record(record_url=rec.links.self_)
    assert rec.metadata == rec3.metadata
    assert rec.id == rec3.id

    # giving both should fail
    with pytest.raises(AssertionError):
        records_client.read_record(record_id=rec.id, record_url=rec.links.self_)

    # giving none should fail
    with pytest.raises(AssertionError):
        records_client.read_record()


def test_remove_draft_record(local_client: SyncClient):
    records_client = local_client.user_records()
    rec = records_client.create_record(
        {"metadata": {"title": "test"}}, community="acom"
    )
    rec2 = records_client.read_record(record_id=rec.id)
    assert isinstance(rec2, Record)

    rec2.delete()
    with pytest.raises(RepositoryCommunicationError):
        records_client.read_record(record_id=rec.id)


def test_update_draft_record(local_client: SyncClient):
    records_client = local_client.user_records()
    rec = records_client.create_record(
        {"metadata": {"title": "test"}}, community="acom"
    )
    created_etag = rec._etag

    rec2 = records_client.read_record(record_id=rec.id)
    read_etag = rec2._etag

    assert read_etag == created_etag

    # perform update
    rec2.metadata["title"] = "test2"
    rec3 = rec2.update()

    updated_etag = rec3._etag
    assert read_etag != updated_etag

    rec4 = records_client.read_record(record_id=rec.id)
    assert rec4.metadata["title"] == "test2"
    assert rec4._etag == updated_etag


def test_read_all_records(local_client: SyncClient):
    # create 30 records
    records_client = local_client.user_records()
    for i in range(30):
        records_client.create_record(
            {"metadata": {"title": f"test{i}"}}, community="acom"
        )

    # read all records and check if they are at least 30, that is that pagination works
    fetched_records = []

    for record in (local_client.user_records().search(size=10, state="draft")).all():
        fetched_records.append(record)

    print(f"Total fetched records: {len(fetched_records)}")
    assert len(fetched_records) >= 30

    for record in fetched_records:
        record.delete()

    # now create controlled records
    created_records = []
    for i in range(10):
        created_records.append(
            records_client.create_record(
                {"metadata": {"title": f"test{i}"}}, community="acom"
            )
        )

    # and search
    fetched_records = [x for x in (local_client.user_records().search(q="test1")).all()]

    assert len(fetched_records) == 1
    f = fetched_records[0]
    assert f.metadata["title"] == "test1"

    # and clean up
    for record in created_records:
        record.delete()


def test_custom_record_class(nrp_repository_config):
    class MyMetadata(Model):
        title: str

    class MyRecord(Record):
        metadata: MyMetadata

    client = SyncClient[MyRecord, File, Request, RequestType](
        alias="local", config=nrp_repository_config
    )
    client.info()

    assert client._generic_arguments.RecordBase == MyRecord

    records_client = client.user_records
    rec = records_client().create_record(
        {"metadata": {"title": "test"}}, community="acom"
    )
    assert isinstance(rec, MyRecord)
    assert isinstance(rec.metadata, MyMetadata)
    assert rec.metadata.title == "test"

    rec2 = records_client().read_record(record_id=rec.id)
    assert isinstance(rec2, MyRecord)
    assert isinstance(rec2.metadata, MyMetadata)
    assert rec2.metadata.title == "test"

    reclist = records_client().search(size=1)
    assert len(reclist) == 1
    assert isinstance(reclist.hits[0], MyRecord)
    assert isinstance(reclist.hits[0].metadata, MyMetadata)
