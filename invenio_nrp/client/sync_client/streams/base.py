#
# This file was generated from the asynchronous client at streams/base.py by generate_synchronous_client.sh
# Do not edit this file directly, instead edit the original file and regenerate this file.
#


"""Protocol for data sources and sinks."""

from collections.abc import Iterator
from enum import StrEnum, auto
from typing import Protocol


class InputStream(Protocol):
    """Protocol for data readers."""

    def read(self, n: int = -1) -> bytes:
        ...
        
    def __iter__(self) -> Iterator[bytes]:
        ...

    def close(self) -> None:
        ...


class OutputStream(Protocol):
    """Protocol for data writers."""

    def write(self, data: bytes) -> int:
        ...

    def close(self) -> None:
        ...


class SinkState(StrEnum):
    """State of the sink."""

    NOT_ALLOCATED = auto()
    """Sink's space has not been allocated yet."""
    ALLOCATED = auto()
    """Sink's space has been allocated and reserved on the filesystem/memory."""
    CLOSED = auto()
    """Sink has been closed."""


class DataSink(Protocol):
    """Protocol for data sinks."""

    def allocate(self, size: int) -> None:
        """Allocate space for the sink.

        :param size: The size of the sink in bytes.
        """
        ...

    def open_chunk(self, offset: int = 0) -> OutputStream:
        """Get a writer for the sink, starting at the given offset.

        :param offset: The offset in bytes from the start of the sink.
        :return: A writer for the sink.
        """
        ...

    def close(self) -> None:
        """Close the sink and all unclosed writers."""
        ...

    @property
    def state(self) -> SinkState:
        """Return the current state of the sink."""
        ...


class DataSource(Protocol):
    """Protocol for data sources."""

    has_range_support: bool = False

    def open(self, offset: int = 0, count: int | None = None) -> InputStream:
        """Open the data source for reading.

        :param offset:      where to start reading from
        :param count:       how many bytes to read, if None, read until the end
        :return:            a reader for the data source
        """
        ...

    def size(self) -> int:
        """Return the length of the data source in bytes."""
        ...

    def content_type(self) -> str:
        """Return the content type of the data source."""
        ...

    def close(self) -> None:
        """Close the data source."""
        ...

