#
# This file was generated from the asynchronous client at files/sink/file.py by generate_synchronous_client.sh
# Do not edit this file directly, instead edit the original file and regenerate this file.
#


"""Implementation of a sink that writes data to filesystem."""

import contextlib
from pathlib import Path
from typing import ContextManager, Iterator

from ..os import DataWriter, open_file
from .base import DataSink, SinkState


class FileSink(DataSink):
    """Implementation of a sink that writes data to filesystem."""

    def __init__(self, fpath: Path):
        """Initialize the sink.
        :param fpath: The path to the file where the data will be written.
        """
        self._fpath = fpath
        self._state = SinkState.NOT_ALLOCATED
        self._file: DataWriter | None = None

    def allocate(self, size: int) -> None:
        self._file = open_file(self._fpath, mode="wb")
        self._file.truncate(size)
        self._state = SinkState.ALLOCATED

    @contextlib.contextmanager
    def open_chunk(self, offset: int = 0) -> Iterator[DataWriter]:   # type: ignore
        if self._state != SinkState.ALLOCATED:
            raise RuntimeError("Sink not allocated")

        chunk = open_file(self._fpath, mode="r+b")
        chunk.seek(offset)
        yield chunk
        chunk.close()

    def close(self) -> None:
        if self._file is not None:
            try:
                self._file.close()
            except:  # noqa just catch everything here
                pass
        self._file = None

        self._state = SinkState.CLOSED

    @property
    def state(self) -> SinkState:
        """Return the current state of the sink."""
        return self._state

    def __repr__(self):
        return f"<{self.__class__.__name__} {self._fpath} {self._state}>"
